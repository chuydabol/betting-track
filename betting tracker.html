<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Slip Tracker — Multipliers</title>
  <style>
    :root{
      --bg: #0b0f19;
      --panel: rgba(255,255,255,0.06);
      --panel2: rgba(255,255,255,0.08);
      --border: rgba(255,255,255,0.12);
      --text: rgba(255,255,255,0.92);
      --muted: rgba(255,255,255,0.65);
      --muted2: rgba(255,255,255,0.45);
      --accent: #6ea8ff;
      --accent2:#8b5cf6;
      --good:#4ade80;
      --bad:#fb7185;
      --warn:#fbbf24;
      --shadow: 0 18px 45px rgba(0,0,0,.35);
      --radius: 16px;
      --radius2: 12px;
      --pad: 14px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    }

    *{ box-sizing:border-box; }
    html, body{ height:100%; }
    body{
      margin:0;
      font-family: var(--sans);
      background:
        radial-gradient(900px 500px at 20% 0%, rgba(110,168,255,.18), transparent 60%),
        radial-gradient(700px 500px at 85% 10%, rgba(139,92,246,.14), transparent 55%),
        var(--bg);
      color: var(--text);
      overflow-x: hidden; /* important: prevents page-level horizontal scroll */
    }

    .wrap{ max-width: 1200px; margin: 16px auto 60px; padding: 0 14px; }
    .skip-link{
      position: absolute;
      top: -40px;
      left: 12px;
      background: #111827;
      color: var(--text);
      padding: 8px 12px;
      border-radius: 10px;
      border: 1px solid var(--border);
      z-index: 1001;
      transition: top .15s ease;
    }
    .skip-link:focus{ top: 10px; }
    .sr-only{
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      border: 0;
    }

    /* Topbar */
    .topbar{
      position: sticky; top: 0; z-index: 50;
      backdrop-filter: blur(10px);
      background: linear-gradient(to bottom, rgba(11,15,25,.82), rgba(11,15,25,.35));
      border-bottom: 1px solid var(--border);
      padding: 10px 0;
    }
    .topbar .inner{
      max-width: 1200px; margin: 0 auto; padding: 0 14px;
      display:flex; align-items:center; justify-content:space-between; gap: 12px;
    }
    .brand{ display:flex; flex-direction:column; gap:2px; min-width: 180px; }
    .brand h1{ margin:0; font-size: 16px; letter-spacing:.2px; }
    .brand .sub{ font-size: 12px; color: var(--muted); }

    .top-actions{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; justify-content:flex-end; }

    /* Buttons & inputs */
    .btn{
      appearance:none; border: 1px solid var(--border);
      background: rgba(255,255,255,0.06);
      color: var(--text);
      padding: 10px 12px;
      border-radius: 12px;
      cursor:pointer;
      transition: transform .06s ease, background .2s ease, border-color .2s ease, opacity .2s ease;
      font-weight: 700;
      font-size: 13px;
      line-height: 1;
      display:inline-flex; gap:8px; align-items:center; justify-content:center;
      min-height: 40px;
      user-select:none;
      white-space: nowrap;
    }
    .btn:hover{ background: rgba(255,255,255,0.10); }
    .btn:active{ transform: translateY(1px); }
    .btn:focus-visible,
    input:focus-visible,
    select:focus-visible,
    textarea:focus-visible,
    .kebab:focus-visible{
      outline: 2px solid rgba(110,168,255,.7);
      outline-offset: 2px;
    }
    .btn.primary{
      background: linear-gradient(135deg, rgba(110,168,255,.95), rgba(139,92,246,.85));
      border-color: rgba(255,255,255,0.18);
      color: #0b0f19;
    }
    .btn.danger{
      background: rgba(251,113,133,.13);
      border-color: rgba(251,113,133,.25);
      color: rgba(255,255,255,.95);
    }
    .btn.ghost{ background: transparent; }

    input, select, textarea{
      width:100%;
      background: rgba(255,255,255,0.05);
      border: 1px solid var(--border);
      color: var(--text);
      border-radius: 12px;
      padding: 10px 12px;
      outline: none;
      min-height: 40px;
      font-size: 14px;
    }
    textarea{ min-height: 72px; resize: vertical; }
    input:focus, select:focus, textarea:focus{
      border-color: rgba(110,168,255,.55);
      box-shadow: 0 0 0 3px rgba(110,168,255,.18);
    }
    label{ font-size: 12px; color: var(--muted); display:block; margin-bottom: 6px; }

    .card{
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: var(--pad);
      min-width: 0; /* critical for grid overflow */
    }

    /* Responsive layout */
    .grid{
      display:grid; gap: 14px;
      grid-template-columns: minmax(0, 1.3fr) minmax(0, .7fr);
      margin-top: 16px;
      align-items:start;
    }
    @media (max-width: 1180px){
      .grid{ grid-template-columns: 1fr; }
    }

    .row{
      display:grid; gap: 10px;
      grid-template-columns: repeat(12, minmax(0, 1fr));
    }
    .col-3{ grid-column: span 3; }
    .col-4{ grid-column: span 4; }
    .col-6{ grid-column: span 6; }
    .col-12{ grid-column: span 12; }

    @media (max-width: 980px){
      .row{ grid-template-columns: repeat(6, minmax(0, 1fr)); }
      .col-3,.col-4,.col-6{ grid-column: span 6; }
    }

    .section-title{
      display:flex; align-items:center; justify-content:space-between;
      gap: 10px;
      margin-bottom: 10px;
      flex-wrap:wrap;
    }
    .section-title h2{ margin:0; font-size: 14px; letter-spacing:.2px; }
    .hint{ color: var(--muted); font-size: 12px; }

    /* KPIs */
    .kpis{
      display:grid; gap: 10px;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      margin-top: 10px;
    }
    @media (min-width: 560px){
      .kpis{ grid-template-columns: repeat(4, minmax(0, 1fr)); }
    }
    .kpi{
      border: 1px solid var(--border);
      background: rgba(255,255,255,0.04);
      border-radius: 14px;
      padding: 12px;
      min-width: 0;
    }

    .profile-grid{
      display:grid;
      gap: 12px;
      grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
    }
    .profile-card{
      border: 1px solid var(--border);
      border-radius: 14px;
      padding: 12px;
      background: rgba(255,255,255,0.04);
      display:flex;
      flex-direction:column;
      gap: 10px;
      min-width: 0;
    }
    .profile-card h3{
      margin: 0;
      font-size: 14px;
      letter-spacing: .2px;
    }
    .profile-meta{
      color: var(--muted);
      font-size: 12px;
    }
    .profile-stats{
      display:grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 8px;
    }
    .profile-stat{
      background: rgba(255,255,255,0.05);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 8px 10px;
    }
    .profile-stat .k{ font-size: 11px; color: var(--muted2); }
    .profile-stat .v{ font-weight: 800; margin-top: 4px; }
    .profile-list{
      display:grid;
      gap: 6px;
      font-size: 12px;
      color: var(--muted);
    }
    .profile-pill{
      display:inline-flex;
      align-items:center;
      gap: 6px;
      border-radius: 999px;
      padding: 2px 8px;
      background: rgba(255,255,255,0.08);
      border: 1px solid var(--border);
      font-size: 11px;
      color: var(--text);
    }
    .kpi .k{ font-size: 12px; color: var(--muted); }
    .kpi .v{ margin-top: 6px; font-size: 18px; font-weight: 900; }
    .pos{ color: var(--good); }
    .neg{ color: var(--bad); }
    .neu{ color: var(--warn); }
    .bankline{ margin-top: 10px; color: var(--muted); font-size: 12px; }
    .chart-wrap{
      margin-top: 12px;
      padding: 10px;
      border-radius: 14px;
      border: 1px solid var(--border);
      background: rgba(255,255,255,0.03);
    }
    #bankrollChart{
      width: 100%;
      height: 180px;
      display: block;
    }

    /* Table wrapper: prevents page overflow */
    .tablewrap{
      border: 1px solid var(--border);
      border-radius: var(--radius);
      overflow: hidden;
      background: rgba(255,255,255,0.03);
      min-width: 0;
    }
    .table-scroll{
      max-height: 460px;
      overflow: auto;              /* vertical + horizontal inside */
      overscroll-behavior: contain;
      -webkit-overflow-scrolling: touch;
    }
    table{
      width:100%;
      border-collapse: collapse;
      table-layout: fixed;         /* stops columns from forcing huge widths */
      min-width: 860px;            /* only the inner scroller scrolls horizontally */
    }
    th, td{
      border-bottom: 1px solid rgba(255,255,255,0.08);
      padding: 10px 10px;
      font-size: 13px;
      vertical-align: top;
      text-align:left;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    th{
      position: sticky; top: 0; z-index: 5;
      background: rgba(11,15,25,.88);
      backdrop-filter: blur(10px);
      color: rgba(255,255,255,0.78);
      font-size: 12px;
      letter-spacing: .2px;
    }
    td.right, th.right{ text-align:right; }
    .mono{ font-family: var(--mono); }
    caption{
      text-align:left;
      padding: 10px;
      font-size: 12px;
      color: var(--muted);
    }

    /* Players truncate in table */
    .notes-trunc{
      white-space: nowrap;
      max-width: 340px;
    }

    /* Pills */
    .pill{
      display:inline-flex; align-items:center; gap: 6px;
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(255,255,255,0.05);
      font-size: 12px;
      color: rgba(255,255,255,0.85);
      white-space: nowrap;
    }
    .pill.pending{ border-color: rgba(251,191,36,.22); background: rgba(251,191,36,.10); }
    .pill.win{ border-color: rgba(74,222,128,.22); background: rgba(74,222,128,.10); }
    .pill.loss{ border-color: rgba(251,113,133,.22); background: rgba(251,113,133,.10); }
    .pill.push{ border-color: rgba(110,168,255,.22); background: rgba(110,168,255,.10); }

    /* Kebab actions */
    .kebab{
      width: 38px; height: 38px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.05);
      color: rgba(255,255,255,0.88);
      cursor:pointer;
      display:flex; align-items:center; justify-content:center;
      font-size: 18px;
      line-height: 1;
    }
    .kebab:hover{ background: rgba(255,255,255,0.10); }

    .muteline{ color: var(--muted); font-size: 12px; margin-top: 8px; }

    /* Log view toggles */
    .log-views{ display:flex; gap: 8px; align-items:center; flex-wrap:wrap; }
    .smalltag{ font-size: 12px; color: var(--muted); }

    /* Cards log */
    .cardsWrap{ display:none; gap: 10px; margin-top: 10px; }
    .slipCard{
      border: 1px solid var(--border);
      background: rgba(255,255,255,0.04);
      border-radius: 16px;
      padding: 12px;
      display:grid;
      gap: 10px;
    }
    .slipCard .top{
      display:flex; align-items:flex-start; justify-content:space-between; gap:10px;
    }
    .slipCard .meta{
      display:flex; gap:10px; flex-wrap:wrap; align-items:center;
      color: rgba(255,255,255,0.8);
      font-size: 13px;
    }
    .slipCard .meta .mono{ color: rgba(255,255,255,0.9); }
    .slipCard .grid2{
      display:grid; grid-template-columns: 1fr 1fr; gap: 10px;
    }
    .slipCard .kv{
      border: 1px solid rgba(255,255,255,0.10);
      background: rgba(255,255,255,0.03);
      border-radius: 14px;
      padding: 10px;
      min-width: 0;
    }
    .slipCard .kv .k{ font-size: 12px; color: var(--muted); }
    .slipCard .kv .v{ margin-top: 4px; font-weight: 900; }
    .slipCard .notes{
      white-space: pre-wrap;
      color: rgba(255,255,255,0.82);
      border-top: 1px solid rgba(255,255,255,0.10);
      padding-top: 10px;
      font-size: 13px;
    }
    @media (max-width: 520px){
      .slipCard .grid2{ grid-template-columns: 1fr; }
    }

    /* Show cards on small screens (auto mode) */
    body.view-auto .cardsWrap{ display: grid; }
    body.view-auto .tablewrap{ display:none; }
    @media (min-width: 900px){
      body.view-auto .cardsWrap{ display:none; }
      body.view-auto .tablewrap{ display:block; }
    }

    body.view-table .cardsWrap{ display:none !important; }
    body.view-table .tablewrap{ display:block !important; }

    body.view-cards .cardsWrap{ display:grid !important; }
    body.view-cards .tablewrap{ display:none !important; }

    /* Floating menu / bottom sheet */
    .menu{
      position: fixed;
      z-index: 1000;
      width: 330px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.16);
      background: rgba(17,24,39,.88);
      backdrop-filter: blur(12px);
      box-shadow: 0 20px 55px rgba(0,0,0,.55);
      padding: 10px;
      display:none;
      max-width: calc(100vw - 20px);
    }
    .menu .title{
      display:flex; align-items:center; justify-content:space-between;
      gap: 8px;
      padding: 6px 6px 10px;
      border-bottom: 1px solid rgba(255,255,255,0.10);
      margin-bottom: 10px;
    }
    .menu .title .t{ font-weight: 900; font-size: 13px; }
    .menu .title .x{
      border:none; background: transparent; color: rgba(255,255,255,.85);
      font-size: 18px; cursor:pointer;
    }
    .menu .grid2{ display:grid; grid-template-columns: 1fr 1fr; gap: 8px; }
    .menu .grid1{ display:grid; gap: 8px; }
    .menu small{ color: rgba(255,255,255,0.65); }
    .menu .line{ border-top: 1px solid rgba(255,255,255,0.10); margin: 10px 0; }

    /* bottom sheet on mobile */
    @media (max-width: 600px){
      .menu{
        left: 10px !important;
        right: 10px !important;
        bottom: 10px !important;
        top: auto !important;
        width: auto !important;
        border-radius: 18px;
      }
    }

    @media (prefers-reduced-motion: reduce){
      *{
        scroll-behavior: auto !important;
        transition-duration: 0.001ms !important;
      }
    }
  </style>
</head>

<body class="view-auto">
  <a class="skip-link" href="#main">Skip to content</a>
  <div class="topbar">
    <div class="inner">
      <div class="brand">
        <h1>Slip Tracker</h1>
        <div class="sub">player props • multipliers • pending slips • import/export</div>
      </div>
      <div class="top-actions">
        <button class="btn" id="exportBtn">Export TXT</button>
        <button class="btn" id="exportCsvBtn">Export CSV</button>
        <label class="btn ghost" style="gap:10px; padding:10px 12px;">
          Import
          <input id="importFile" type="file" accept=".txt,.json" style="display:none;">
        </label>
      </div>
    </div>
  </div>

  <main class="wrap" id="main">
    <div class="grid">
      <!-- Left -->
      <div class="card">
        <div class="section-title">
          <h2>Add Slip</h2>
          <span class="hint">Add as Pending, finish later</span>
        </div>

        <div class="row" role="group" aria-label="Add slip form">
          <div class="col-3">
            <label for="date">Date</label>
            <input id="date" type="date" />
          </div>
          <div class="col-3">
            <label for="status">Status</label>
            <select id="status" aria-describedby="statusHelp">
              <option value="PENDING">Pending</option>
              <option value="DONE">Finished</option>
            </select>
            <div class="muteline" id="statusHelp">Set to Finished to unlock the result field.</div>
          </div>
          <div class="col-3">
            <label for="result">Result (only if finished)</label>
            <select id="result" aria-describedby="resultHelp">
              <option value="W">Win</option>
              <option value="L">Loss</option>
              <option value="P">Push</option>
            </select>
            <div class="muteline" id="resultHelp">Disabled unless Status is Finished.</div>
          </div>
          <div class="col-3">
            <label for="app">App (optional)</label>
            <input id="app" type="text" list="appList" placeholder="PrizePicks" />
          </div>
          <div class="col-3">
            <label for="sportsbook">Sportsbook (optional)</label>
            <input id="sportsbook" type="text" list="sportsbookList" placeholder="FanDuel" />
          </div>
          <div class="col-3">
            <label for="league">League (optional)</label>
            <input id="league" type="text" list="leagueList" placeholder="NBA" />
          </div>
          <div class="col-3">
            <label for="oddsType">Odds Type (optional)</label>
            <select id="oddsType">
              <option value="">Select</option>
              <option value="standard">Standard</option>
              <option value="boost">Boost</option>
              <option value="promo">Promo</option>
            </select>
          </div>
          <div class="col-3">
            <label for="analystId">Analyst ID</label>
            <select id="analystId"></select>
          </div>
          <div class="col-3">
            <label for="analystType">Analyst Type</label>
            <select id="analystType">
              <option value="VIP">VIP</option>
              <option value="Tryout">Tryout</option>
              <option value="Own">Own</option>
            </select>
          </div>
          <div class="col-3">
            <label for="slipType">Slip Type</label>
            <select id="slipType">
              <option value="">Auto</option>
              <option value="Straight">Straight</option>
              <option value="Parlay">Parlay</option>
            </select>
          </div>
          <div class="col-3">
            <label for="legsCount">Legs Count</label>
            <input id="legsCount" type="number" min="1" step="1" placeholder="2" />
          </div>

          <div class="col-3">
            <label for="stake">Stake ($)</label>
            <input id="stake" type="number" step="0.01" placeholder="50" min="0.01" inputmode="decimal" />

          </div>
          <div class="col-3">
            <label for="mult">Listed Multiplier (x)</label>
            <input id="mult" type="number" step="0.01" placeholder="2.0" min="0.01" inputmode="decimal" />
          </div>
          <div class="col-3">
            <label for="paid">Paid Multiplier (optional)</label>
            <input id="paid" type="number" step="0.01" placeholder="1.8" min="0" inputmode="decimal" />
          </div>
          <div class="col-3">
            <label for="tag">Tag (optional)</label>
            <input id="tag" type="text" list="tagList" placeholder="Parlay" />
          </div>
          <div class="col-3">
            <label for="group">Group / Session (optional)</label>
            <input id="group" type="text" list="groupList" placeholder="Weekend slate" />
          </div>

          <div class="col-6">
            <label for="slipId">Slip ID (optional)</label>
            <input id="slipId" type="text" list="slipIdList" placeholder="ABC123" />
          </div>
          <div class="col-12">
            <div class="section-title" style="margin-top:6px;">
              <h2>Players / Props</h2>
              <button class="btn" id="addPlayerBtn" type="button">Add Player</button>
            </div>
            <div id="players" style="display:grid; gap:10px;"></div>
          </div>

          <div class="col-12" style="display:flex; gap:10px; flex-wrap:wrap;">
            <button class="btn primary" id="addBtn" style="flex: 1 1 220px;">Add Slip</button>
            <button class="btn" id="addPendingBtn" style="flex: 1 1 220px;">Quick Add Pending</button>
            <button class="btn danger" id="clearBtn" style="flex: 1 1 220px;">Clear All</button>
          </div>
        </div>

        <div class="muteline">
          Finished payout: <span class="mono">stake × (paid x if set else listed x)</span>. Pending slips don’t affect profit.
        </div>

        <datalist id="appList"></datalist>
        <datalist id="sportsbookList"></datalist>
        <datalist id="leagueList"></datalist>
        <datalist id="tagList"></datalist>
        <datalist id="groupList"></datalist>
        <datalist id="slipIdList"></datalist>

        <div style="height:14px"></div>

        <div class="section-title">
          <h2>Slip Log</h2>
          <div class="log-views">
            <span class="smalltag">View</span>
            <select id="logView" style="width: 150px;">
              <option value="auto">Auto</option>
              <option value="table">Table</option>
              <option value="cards">Cards</option>
            </select>
            <span class="hint">Use ⋯ for actions</span>
          </div>
        </div>

        <!-- TABLE VIEW -->
        <div class="tablewrap">
          <div class="table-scroll">
            <table>

              <thead>
                <tr>
                  <th scope="col" style="width: 96px;">Date</th>
                  <th scope="col" style="width: 110px;">Status</th>
                  <th scope="col" style="width: 120px;">App</th>
                  <th scope="col" style="width: 120px;">Sportsbook</th>
                  <th scope="col" style="width: 90px;">League</th>
                  <th scope="col" style="width: 90px;">Odds</th>
                  <th scope="col" style="width: 120px;">Creator</th>
                  <th scope="col" class="right" style="width: 92px;">Stake</th>
                  <th scope="col" class="right" style="width: 72px;">x</th>
                  <th scope="col" class="right" style="width: 92px;">Paid x</th>
                  <th scope="col" class="right" style="width: 100px;">Payout</th>
                  <th scope="col" class="right" style="width: 90px;">P/L</th>
                  <th scope="col" style="width: 90px;">Tag</th>
                  <th scope="col" style="width: 120px;">Group</th>
                  <th scope="col" style="width: 110px;">Slip ID</th>
                  <th scope="col" style="width: 220px;">Players</th>
                  <th scope="col" class="right" style="width: 70px;">⋯</th>
                </tr>
              </thead>
              <tbody id="rows"></tbody>
            </table>
          </div>
        </div>

        <!-- CARDS VIEW -->
        <div class="cardsWrap" id="cards"></div>
      </div>

      <!-- Right -->
      <div style="display:grid; gap: 14px;">
        <div class="card">
          <div class="section-title">
            <h2>KPIs</h2>
            <span class="hint">finished slips only</span>
          </div>
          <div class="row">
            <div class="col-6">
              <label for="viewDate">View Date</label>
              <input id="viewDate" type="date" />
            </div>
            <div class="col-6">
              <label for="bankroll">Starting Bankroll</label>
              <input id="bankroll" type="number" step="0.01" placeholder="1000" inputmode="decimal" />
            </div>
          </div>
          <div class="row">
            <div class="col-12">
              <label for="kpiView">Earnings View</label>
              <select id="kpiView">
                <option value="overall">Overall KPIs</option>
                <option value="creators">By creator category</option>
              </select>
              <div class="muteline">Switch to break down earnings by VIP, tryout, and own slips.</div>
            </div>
          </div>

          <div class="kpis" id="kpis" role="status" aria-live="polite"></div>
          <div class="bankline" id="bankrollLine" role="status" aria-live="polite"></div>
          <div class="chart-wrap">
            <canvas id="bankrollChart" width="640" height="200"></canvas>
          </div>
        </div>

        <div class="card">
          <div class="section-title">
            <h2>Analyst Profiles</h2>
            <span class="hint">finished slips only</span>
          </div>
          <div class="row">
            <div class="col-6">
              <label for="analystPrimary">Primary Analyst</label>
              <select id="analystPrimary"></select>
            </div>
            <div class="col-6">
              <label for="analystCompare">Compare To</label>
              <select id="analystCompare"></select>
            </div>
          </div>
          <div class="profile-grid" id="profileGrid"></div>
        </div>

        <div class="card">
          <div class="section-title">
            <h2>Filters</h2>
            <span class="hint">find slips fast</span>
          </div>
          <div class="row">
            <div class="col-6">
              <label for="filterStatus">Status</label>
              <select id="filterStatus">
                <option value="ALL">All</option>
                <option value="PENDING">Pending</option>
                <option value="DONE">Finished</option>
              </select>
            </div>
            <div class="col-6">
              <label for="sortBy">Sort</label>
              <select id="sortBy">
                <option value="date_desc">Date (new → old)</option>
                <option value="date_asc">Date (old → new)</option>
                <option value="stake_desc">Stake (high → low)</option>
                <option value="stake_asc">Stake (low → high)</option>
              </select>
            </div>
            <div class="col-6">
              <label for="filterDate">Show only date</label>
              <select id="filterDate">
                <option value="ALL">All dates</option>
              </select>
            </div>
            <div class="col-6">
              <label for="search">Search</label>
              <input id="search" type="text" placeholder="type to filter..." />
            </div>
            <div class="col-6">
              <label for="filterGroup">Group / Session</label>
              <select id="filterGroup">
                <option value="ALL">All groups</option>
              </select>
            </div>
            <div class="col-12">
              <label for="autosave">Auto-save</label>
              <select id="autosave">
                <option value="on">On (recommended)</option>
                <option value="off">Off (manual export only)</option>
              </select>
              <div class="muteline">If Auto-save is off, Export TXT so you never lose your log.</div>
            </div>
          </div>
        </div>

      </div>
    </div>
  </main>

  <!-- Floating actions menu -->
  <div class="menu" id="menu">
    <div class="title">
      <div class="t" id="menuTitle">Slip Actions</div>
      <button class="x" id="menuClose" title="Close">×</button>
    </div>

    <div class="grid1">
      <small>Status / result</small>
      <div class="grid2">
        <button class="btn" id="actPending">Mark Pending</button>
        <button class="btn" id="actPush">Mark Push</button>
        <button class="btn" id="actWin">Mark Win</button>
        <button class="btn" id="actLoss">Mark Loss</button>
      </div>

      <div class="line"></div>

      <small>Paid multiplier (optional)</small>
      <div class="grid2">
        <input id="menuPaid" type="number" step="0.01" placeholder="e.g. 1.5" />
        <button class="btn" id="actSavePaid">Save Paid x</button>
      </div>

      <div class="line"></div>

      <button class="btn danger" id="actDelete">Delete Slip</button>
    </div>
  </div>

<script>
(() => {
  const STORAGE_KEY = "slip_tracker_multipliers_pro_v2";
  const PRESET_ANALYSTS = [
    {id: "Jay", type: "VIP"},
    {id: "Ochan", type: "VIP"},
    {id: "Envixity", type: "VIP"},
    {id: "Fluid", type: "Tryout"},
    {id: "Pops", type: "Tryout"},
    {id: "Chuy", type: "Own"}
  ];
  const DEFAULT_ANALYST_ID = "Chuy";
  const PRESET_ANALYST_MAP = new Map(
    PRESET_ANALYSTS.map(({id, type}) => [id.toUpperCase(), {id, type}])
  );

  let state = {
    startingBankroll: 0,
    autosave: "on",
    logView: "auto", // auto | table | cards
    kpiView: "overall", // overall | creators
    analystPrimary: "",
    analystCompare: "",
    slips: []
  };

  const $ = (id) => document.getElementById(id);

  const num = (v) => {
    const n = Number(v);
    return Number.isFinite(n) ? n : 0;
  };

  const todayISO = () => {
    const d = new Date();
    const p = (x) => String(x).padStart(2,'0');
    return `${d.getFullYear()}-${p(d.getMonth()+1)}-${p(d.getDate())}`;
  };

  const fmtMoney = (n) => num(n).toLocaleString(undefined, {style:"currency", currency:"USD"});
  const fmtPct = (n) => (Number.isFinite(n) ? (n*100).toFixed(1)+"%" : "0.0%");

  const clamp = (v, min, max) => Math.min(max, Math.max(min, v));

  const escapeHtml = (s) => String(s||"")
    .replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;")
    .replaceAll('"',"&quot;").replaceAll("'","&#039;");

  const genId = () => (crypto.randomUUID ? crypto.randomUUID() : String(Math.random()).slice(2));

  const parseTags = (value) => {
    if(!value) return [];
    return value.split(",").map(tag => tag.trim()).filter(Boolean);
  };

  const normalizeTags = (slip) => {
    const tags = Array.isArray(slip.tags) ? slip.tags : parseTags(slip.tags);
    if(tags.length) return tags;
    return parseTags(slip.tag);
  };

  const getPresetAnalystType = (analystId) => {
    const entry = PRESET_ANALYST_MAP.get(String(analystId || "").toUpperCase());
    return entry ? entry.type : null;
  };

  const playersContainer = () => $("players");
  const playerRowTemplate = (player = {}, index = 0) => `
    <div class="row" data-player-row>
      <div class="col-6">
        <label>Player ${index + 1}</label>
        <input type="text" class="player-name" placeholder="Player name" value="${escapeHtml(player.name || "")}" />
      </div>
      <div class="col-3">
        <label>Prop Line</label>
        <input type="number" class="player-line" step="0.1" placeholder="15.5" value="${escapeHtml(player.line || "")}" />
      </div>
      <div class="col-3">
        <label>O/U</label>
        <select class="player-ou">
          <option value="">Select</option>
          <option value="Over" ${player.ou === "Over" ? "selected" : ""}>Over</option>
          <option value="Under" ${player.ou === "Under" ? "selected" : ""}>Under</option>
        </select>
        <button class="btn danger remove-player" type="button" title="Remove player" style="margin-top:10px; width:100%;">Remove</button>
      </div>
    </div>
  `;

  function renderPlayers(players){
    const container = playersContainer();
    if(!container) return;
    const list = players.length ? players : [{name:"", line:"", ou:""}];
    container.innerHTML = list.map((player, idx) => playerRowTemplate(player, idx)).join("");
  }

  function readPlayersDraft(){
    const container = playersContainer();
    if(!container) return [];
    return Array.from(container.querySelectorAll("[data-player-row]")).map(row => ({
      name: row.querySelector(".player-name")?.value.trim() || "",
      line: row.querySelector(".player-line")?.value.trim() || "",
      ou: row.querySelector(".player-ou")?.value || ""
    }));
  }

  function readPlayersFromForm(){
    const draft = readPlayersDraft();
    const players = [];
    for(const player of draft){
      const {name, line, ou} = player;
      if(!name && !line && !ou) continue;
      if(!name || !line || !ou){
        alert("Each player row needs a name, prop line, and over/under selection.");
        return null;
      }
      players.push({name, line, ou});
    }
    return players;
  }

  function setBodyView(){
    document.body.classList.remove("view-auto","view-table","view-cards");
    const v = state.logView || "auto";
    document.body.classList.add(v === "table" ? "view-table" : v === "cards" ? "view-cards" : "view-auto");
  }

  function load(){
    try{
      const raw = localStorage.getItem(STORAGE_KEY);
      if(!raw) return;
      const parsed = JSON.parse(raw);
      if(!parsed || typeof parsed !== "object") return;
      state.startingBankroll = num(parsed.startingBankroll);
      state.autosave = parsed.autosave === "off" ? "off" : "on";
      state.logView = (parsed.logView === "table" || parsed.logView === "cards") ? parsed.logView : "auto";
      state.kpiView = parsed.kpiView === "creators" ? "creators" : "overall";
      state.analystPrimary = parsed.analystPrimary || "";
      state.analystCompare = parsed.analystCompare || "";
      state.slips = Array.isArray(parsed.slips) ? parsed.slips : [];
    }catch{}
  }

  function save(){
    if(state.autosave !== "on") return;
    try{ localStorage.setItem(STORAGE_KEY, JSON.stringify(state)); }catch{}
  }

  function payoutFor(s){
    if(s.status !== "DONE") return null;
    if(s.result === "L") return 0;
    if(s.result === "P") return num(s.stake);
    const paidOk = s.paidMult !== "" && s.paidMult !== null && s.paidMult !== undefined && Number.isFinite(Number(s.paidMult));
    const used = paidOk ? num(s.paidMult) : num(s.mult);
    return num(s.stake) * used;
  }

  function plFor(s){
    const p = payoutFor(s);
    if(p === null) return null;
    return p - num(s.stake);
  }

  function deriveAnalystType(analystId){
    return getPresetAnalystType(analystId) || "Own";
  }

  function syncAnalystType(analystId){
    const analystType = $("analystType");
    const derived = getPresetAnalystType(analystId);
    if(analystType && derived){
      analystType.value = derived;
    }
  }

  function decimalToAmerican(decimalOdds){
    const d = num(decimalOdds);
    if(d <= 1) return null;
    if(d >= 2) return Math.round((d - 1) * 100);
    return Math.round(-100 / (d - 1));
  }

  function oddsRangeLabel(decimalOdds){
    const american = decimalToAmerican(decimalOdds);
    if(american === null) return "Unknown";
    if(american >= -110 && american <= 100) return "-110 to +100";
    if(american > 100 && american <= 200) return "+100 to +200";
    if(american > 200) return "+200+";
    return "< -110";
  }

  function unitProfitFor(slip){
    if(slip.result === "Win") return slip.oddsDecimal - 1;
    if(slip.result === "Loss") return -1;
    return 0;
  }

  function asAnalystSlip(s){
    const legsFromPlayers = Array.isArray(s.players) ? s.players.length : 0;
    const oddsDecimal = num(s.oddsDecimal) || num(s.mult) || 0;
    const legsCount = Math.max(1, num(s.legsCount) || legsFromPlayers || 1);
    const slipType = s.slipType || (legsCount > 1 ? "Parlay" : "Straight");
    const analystId = (s.analystId || s.creator || "Unknown").trim() || "Unknown";
    const analystType = s.analystType || deriveAnalystType(analystId);
    const confidence = Number.isFinite(Number(s.confidence)) ? num(s.confidence) : null;
    return {
      analystId,
      analystType,
      stake: num(s.stake),
      oddsDecimal,
      result: s.result === "W" ? "Win" : s.result === "L" ? "Loss" : "Push",
      slipType,
      legsCount,
      marketType: s.marketType || s.league || "",
      confidence: (confidence && confidence >= 1 && confidence <= 5) ? confidence : null,
      tags: normalizeTags(s),
      date: s.date || "",
      league: s.league || "",
      raw: s
    };
  }

  function analyzeAnalystProfiles(doneSlips){
    const normalized = doneSlips.map(asAnalystSlip);
    const byAnalyst = new Map();
    normalized.forEach(slip => {
      if(!byAnalyst.has(slip.analystId)) byAnalyst.set(slip.analystId, []);
      byAnalyst.get(slip.analystId).push(slip);
    });
    PRESET_ANALYSTS.forEach(({id}) => {
      if(!byAnalyst.has(id)) byAnalyst.set(id, []);
    });

    const profiles = {};
    for(const [analystId, slips] of byAnalyst.entries()){
      if(slips.length){
        profiles[analystId] = buildAnalystProfile(analystId, slips);
      }else{
        const profile = buildAnalystProfile(analystId, []);
        const presetType = getPresetAnalystType(analystId);
        if(presetType) profile.analystType = presetType;
        profiles[analystId] = profile;
      }
    }
    return profiles;
  }

  function buildAnalystProfile(analystId, slips){
    const ordered = slips.slice().sort((a,b) => {
      const dateSort = (a.date||"").localeCompare(b.date||"");
      if(dateSort !== 0) return dateSort;
      return (a.raw.createdAt||0) - (b.raw.createdAt||0);
    });
    const totalProfit = slips.reduce((a,s) => a + (plFor(s.raw) ?? 0), 0);
    const totalStaked = slips.reduce((a,s) => a + num(s.stake), 0);
    const overallROI = totalStaked > 0 ? totalProfit / totalStaked : 0;

    const wins = slips.filter(s => s.result === "Win").length;
    const losses = slips.filter(s => s.result === "Loss").length;
    const pushes = slips.filter(s => s.result === "Push").length;
    const hitRate = (wins + losses) > 0 ? wins / (wins + losses) : 0;

    const impliedAvg = slips.length
      ? slips.reduce((a,s) => a + (s.oddsDecimal > 0 ? (1 / s.oddsDecimal) : 0), 0) / slips.length
      : 0;
    const edge = hitRate - impliedAvg;

    const profitPerSlip = slips.length ? totalProfit / slips.length : 0;
    const profitPer100 = totalStaked > 0 ? (totalProfit / totalStaked) * 100 : 0;
    const avgOddsTaken = slips.length ? slips.reduce((a,s) => a + num(s.oddsDecimal), 0) / slips.length : 0;

    const profitSeries = slips.map(s => plFor(s.raw) ?? 0);
    const volatility = stdDev(profitSeries);
    const volatilityBucket = volatility < 5 ? "Low" : volatility < 15 ? "Medium" : "High";

    const drawdownStats = drawdownFor(ordered);
    const losingStreaks = losingStreakStats(ordered);

    const last10 = ordered.slice(-10);
    const last25 = ordered.slice(-25);
    const last10ROI = roiFor(last10);
    const last25ROI = roiFor(last25);
    const trendDirection = last10ROI > overallROI + 0.02 ? "Improving" :
      last10ROI < overallROI - 0.02 ? "Declining" : "Flat";
    const status = last10ROI > 0.15 ? "HOT" : last10ROI < -0.15 ? "COLD" : "NEUTRAL";

    const oddsStats = oddsRangeStats(slips);
    const bestOddsRange = pickBestBucket(oddsStats);

    const slipTypeStats = groupBy(slips, s => s.slipType);
    const roiBySlipType = calcRoiByGroup(slipTypeStats);
    const hitRateBySlipType = hitRateByGroup(slipTypeStats);
    const bestSlipType = pickBestBucket(roiBySlipType);

    const legsStats = groupBy(slips, s => s.legsCount);
    const roiByLegs = calcRoiByGroup(legsStats);
    const hitRateByLegs = hitRateByGroup(legsStats);

    const marketStats = groupBy(slips, s => s.marketType || "Unknown");
    const roiByMarket = calcRoiByGroup(marketStats);
    const hitRateByMarket = hitRateByGroup(marketStats);
    const bestMarket = pickBestBucket(roiByMarket);

    const sportStats = groupBy(slips, s => s.league || "Unknown");
    const roiBySport = calcRoiByGroup(sportStats);
    const hitRateBySport = hitRateByGroup(sportStats);

    const tagStats = tagPerformance(slips);

    const legPenalty = legInflationPenalty(slips);
    const overLegging = legPenalty < -0.02;

    const confidenceAccuracy = confidenceCalibration(slips);

    const luckFactor = expectedVsActual(slips);

    const compositeScore = analystCompositeScore({
      roi: overallROI,
      edge,
      consistency: 1 - clamp(Math.abs(last10ROI - overallROI) / 0.2, 0, 1),
      drawdown: drawdownStats.maxDrawdownPct,
      volatility,
      confidenceAccuracy,
      sampleSize: slips.length
    });

    return {
      analystId,
      analystType: slips[0]?.analystType || "Own",
      summary: {
        ROI: overallROI,
        hitRate,
        edge,
        profitPer100,
        volatility: volatilityBucket,
        maxDrawdown: drawdownStats.maxDrawdownPct,
        status
      },
      strengths: {
        bestMarket,
        bestOddsRange,
        bestSlipType
      },
      weaknesses: {
        worstMarket: pickWorstBucket(calcRoiByGroup(marketStats)),
        overLegging,
        highVariance: volatilityBucket === "High"
      },
      trends: {
        last10ROI,
        last25ROI,
        direction: trendDirection
      },
      detail: {
        totalProfit,
        totalStaked,
        wins,
        losses,
        pushes,
        profitPerSlip,
        volatility,
        drawdownStats,
        losingStreaks,
        confidenceAccuracy,
        luckFactor,
        compositeScore,
        avgOddsTaken,
        roiBySlipType,
        hitRateBySlipType,
        roiByLegs,
        hitRateByLegs,
        roiByMarket,
        hitRateByMarket,
        roiBySport,
        hitRateBySport,
        roiByOddsRange: oddsStats,
        legInflationPenalty: legPenalty,
        tagPerformance: tagStats
      }
    };
  }

  function roiFor(slips){
    const staked = slips.reduce((a,s) => a + num(s.stake), 0);
    const profit = slips.reduce((a,s) => a + (plFor(s.raw) ?? 0), 0);
    return staked > 0 ? profit / staked : 0;
  }

  function stdDev(values){
    if(values.length === 0) return 0;
    const mean = values.reduce((a,v) => a + v, 0) / values.length;
    const variance = values.reduce((a,v) => a + Math.pow(v - mean, 2), 0) / values.length;
    return Math.sqrt(variance);
  }

  function drawdownFor(slips){
    let peak = 0;
    let equity = 0;
    let maxDrawdown = 0;
    let drawdownSum = 0;
    let drawdownCount = 0;
    let lastPeakIndex = 0;
    let recoveryTimes = [];
    let currentTroughIndex = null;

    slips.forEach((slip, idx) => {
      equity += unitProfitFor(slip);
      if(equity >= peak){
        if(currentTroughIndex !== null){
          recoveryTimes.push(idx - currentTroughIndex);
          currentTroughIndex = null;
        }
        peak = equity;
        lastPeakIndex = idx;
      }else{
        const dd = peak > 0 ? (peak - equity) / peak : 0;
        maxDrawdown = Math.max(maxDrawdown, dd);
        drawdownSum += dd;
        drawdownCount += 1;
        if(currentTroughIndex === null) currentTroughIndex = lastPeakIndex;
      }
    });

    const avgDrawdown = drawdownCount > 0 ? drawdownSum / drawdownCount : 0;
    const avgRecovery = recoveryTimes.length
      ? recoveryTimes.reduce((a,v) => a + v, 0) / recoveryTimes.length
      : 0;
    return {maxDrawdownPct: maxDrawdown, avgDrawdownPct: avgDrawdown, avgRecovery};
  }

  function losingStreakStats(slips){
    let current = 0;
    let longest = 0;
    const streaks = [];
    slips.forEach(s => {
      if(s.result === "Loss"){
        current += 1;
      }else{
        if(current > 0) streaks.push(current);
        longest = Math.max(longest, current);
        current = 0;
      }
    });
    if(current > 0) streaks.push(current);
    longest = Math.max(longest, current);
    const avg = streaks.length ? streaks.reduce((a,v) => a + v, 0) / streaks.length : 0;
    return {longest, average: avg};
  }

  function groupBy(slips, keyFn){
    const out = new Map();
    slips.forEach(s => {
      const key = keyFn(s);
      if(!out.has(key)) out.set(key, []);
      out.get(key).push(s);
    });
    return out;
  }

  function calcRoiByGroup(groups){
    const out = {};
    for(const [key, slips] of groups.entries()){
      out[key] = roiFor(slips);
    }
    return out;
  }

  function hitRateByGroup(groups){
    const out = {};
    for(const [key, slips] of groups.entries()){
      const wins = slips.filter(s => s.result === "Win").length;
      const losses = slips.filter(s => s.result === "Loss").length;
      out[key] = (wins + losses) > 0 ? wins / (wins + losses) : 0;
    }
    return out;
  }

  function tagPerformance(slips){
    const map = new Map();
    slips.forEach(slip => {
      slip.tags.forEach(tag => {
        if(!map.has(tag)) map.set(tag, []);
        map.get(tag).push(slip);
      });
    });
    return {
      roi: calcRoiByGroup(map),
      hitRate: hitRateByGroup(map)
    };
  }

  function oddsRangeStats(slips){
    const groups = groupBy(slips, s => oddsRangeLabel(s.oddsDecimal));
    return calcRoiByGroup(groups);
  }

  function pickBestBucket(stats){
    const entries = Object.entries(stats);
    if(entries.length === 0) return "—";
    entries.sort((a,b) => b[1] - a[1]);
    return entries[0][0];
  }

  function pickWorstBucket(stats){
    const entries = Object.entries(stats);
    if(entries.length === 0) return "—";
    entries.sort((a,b) => a[1] - b[1]);
    return entries[0][0];
  }

  function legInflationPenalty(slips){
    const parlays = slips.filter(s => s.slipType === "Parlay");
    if(parlays.length < 2) return 0;
    const groups = groupBy(parlays, s => s.legsCount);
    const roiByLegs = calcRoiByGroup(groups);
    const legs = Object.keys(roiByLegs).map(n => Number(n)).filter(n => Number.isFinite(n)).sort((a,b) => a - b);
    if(legs.length < 2) return 0;
    const minLegs = legs[0];
    const maxLegs = legs[legs.length - 1];
    const slope = (roiByLegs[maxLegs] - roiByLegs[minLegs]) / Math.max(1, maxLegs - minLegs);
    return slope;
  }

  function confidenceCalibration(slips){
    const withConfidence = slips.filter(s => s.confidence !== null);
    if(withConfidence.length === 0) return 0.5;
    const grouped = groupBy(withConfidence, s => s.confidence);
    let total = 0;
    let weightedError = 0;
    for(const [level, group] of grouped.entries()){
      const winRate = group.filter(s => s.result === "Win").length / group.length;
      const expected = num(level) / 5;
      weightedError += Math.abs(winRate - expected) * group.length;
      total += group.length;
    }
    const avgError = total > 0 ? weightedError / total : 0;
    return clamp(1 - avgError, 0, 1);
  }

  function expectedVsActual(slips){
    let expected = 0;
    let actual = 0;
    slips.forEach(s => {
      if(s.result === "Push") return;
      const prob = s.oddsDecimal > 0 ? 1 / s.oddsDecimal : 0;
      expected += prob * (s.oddsDecimal - 1) + (1 - prob) * -1;
      actual += unitProfitFor(s);
    });
    return actual - expected;
  }

  function analystCompositeScore({roi, edge, consistency, drawdown, volatility, confidenceAccuracy, sampleSize}){
    const roiScore = normalizeScore(roi, -0.5, 0.5);
    const edgeScore = normalizeScore(edge, -0.1, 0.1);
    const consistencyScore = clamp(consistency, 0, 1) * 100;
    const drawdownScore = 100 * (1 - clamp(drawdown / 0.5, 0, 1));
    const volatilityScore = 100 * (1 - clamp(volatility / 20, 0, 1));
    const confidenceScore = clamp(confidenceAccuracy, 0, 1) * 100;
    const sampleScore = clamp(sampleSize / 50, 0, 1) * 100;

    const weights = {
      roi: 0.25,
      edge: 0.2,
      consistency: 0.15,
      drawdown: 0.15,
      volatility: 0.1,
      confidence: 0.1,
      sample: 0.05
    };

    return (
      roiScore * weights.roi +
      edgeScore * weights.edge +
      consistencyScore * weights.consistency +
      drawdownScore * weights.drawdown +
      volatilityScore * weights.volatility +
      confidenceScore * weights.confidence +
      sampleScore * weights.sample
    );
  }

  function normalizeScore(value, min, max){
    if(min === max) return 50;
    return clamp(((value - min) / (max - min)) * 100, 0, 100);
  }

  function statsForDone(slips){
    const staked = slips.reduce((a,s)=>a+num(s.stake),0);
    const paid = slips.reduce((a,s)=>a + (payoutFor(s) ?? 0),0);
    const net = paid - staked;
    const roi = staked > 0 ? net / staked : 0;
    return {staked, paid, net, roi};
  }

  function statusPill(s){
    if(s.status === "PENDING") return `<span class="pill pending">Pending</span>`;
    if(s.result === "W") return `<span class="pill win">Done • W</span>`;
    if(s.result === "L") return `<span class="pill loss">Done • L</span>`;
    return `<span class="pill push">Done • P</span>`;
  }

  function refreshDateDropdown(){
    const select = $("filterDate");
    const current = select.value;
    const dates = Array.from(new Set(state.slips.map(s => s.date).filter(Boolean))).sort().reverse();
    select.innerHTML = `<option value="ALL">All dates</option>` + dates.map(d => `<option value="${d}">${d}</option>`).join("");
    select.value = dates.includes(current) ? current : "ALL";
  }

  function refreshGroupDropdown(){
    const select = $("filterGroup");
    const current = select.value;
    const groups = Array.from(new Set(state.slips.map(s => s.group).filter(Boolean))).sort();
    select.innerHTML = `<option value="ALL">All groups</option>` + groups.map(g => `<option value="${escapeHtml(g)}">${escapeHtml(g)}</option>`).join("");
    select.value = groups.includes(current) ? current : "ALL";
  }

  function refreshDatalists(){
    const presets = {
      appList: ["PrizePicks", "Underdog", "FanDuel", "DraftKings", "BetMGM", "Caesars"],
      sportsbookList: ["FanDuel", "DraftKings", "BetMGM", "Caesars", "PointsBet", "WynnBET"],
      leagueList: ["NBA", "NFL", "NHL", "MLB", "NCAAF", "NCAAB", "Soccer", "WNBA", "MMA", "Tennis"],
      tagList: ["nba", "nfl", "nhl", "mlb", "props", "parlay", "live"],
      groupList: [],

    };

    const fromSlips = (key) => state.slips.map(s => s[key]).filter(Boolean);
    const tagFromSlips = () => state.slips.flatMap(s => {
      if(Array.isArray(s.tags)) return s.tags;
      if(typeof s.tags === "string") return parseTags(s.tags);
      if(s.tag) return parseTags(s.tag);
      return [];
    });
    const merge = (preset, dynamic) => Array.from(new Set([...preset, ...dynamic])).sort();

    const lists = {
      appList: merge(presets.appList, fromSlips("app")),
      sportsbookList: merge(presets.sportsbookList, fromSlips("sportsbook")),
      leagueList: merge(presets.leagueList, fromSlips("league")),
      tagList: merge(presets.tagList, [...fromSlips("tag"), ...tagFromSlips()]),
      groupList: merge(presets.groupList, fromSlips("group")),

    };

    Object.entries(lists).forEach(([id, values]) => {
      const list = $(id);
      if(!list) return;
      list.innerHTML = values.map(v => `<option value="${escapeHtml(v)}"></option>`).join("");
    });
  }

  function refreshAnalystSelector(){
    const select = $("analystId");
    if(!select) return;
    const presetIds = PRESET_ANALYSTS.map(({id}) => id);
    const presetLookup = new Set(presetIds.map(id => id.toUpperCase()));
    const fromSlips = Array.from(new Set(state.slips.map(s => s.analystId).filter(Boolean)));
    const merged = [
      ...presetIds,
      ...fromSlips.filter(id => !presetLookup.has(String(id).toUpperCase()))
    ];
    const current = select.value;
    select.innerHTML = merged.map(id => `<option value="${escapeHtml(id)}">${escapeHtml(id)}</option>`).join("");
    const fallback = merged.includes(DEFAULT_ANALYST_ID) ? DEFAULT_ANALYST_ID : (merged[0] || "");
    select.value = merged.includes(current) ? current : fallback;
    syncAnalystType(select.value);
  }

  function applyFilters(list){
    const status = $("filterStatus").value;
    const query = $("search").value.trim().toLowerCase();
    const dateFilter = $("filterDate").value;
    const groupFilter = $("filterGroup").value;

    let out = list.slice();

    if(status === "PENDING") out = out.filter(s => s.status === "PENDING");
    if(status === "DONE") out = out.filter(s => s.status === "DONE");
    if(dateFilter !== "ALL") out = out.filter(s => s.date === dateFilter);
    if(groupFilter !== "ALL") out = out.filter(s => (s.group || "") === groupFilter);

    if(query){
      out = out.filter(s =>
        (s.app||"").toLowerCase().includes(query) ||
        (s.sportsbook||"").toLowerCase().includes(query) ||
        (s.league||"").toLowerCase().includes(query) ||
        (s.oddsType||"").toLowerCase().includes(query) ||
        (s.creator||"").toLowerCase().includes(query) ||
        (s.analystId||"").toLowerCase().includes(query) ||
        (s.marketType||"").toLowerCase().includes(query) ||
        (Array.isArray(s.tags) ? s.tags.join(" ") : "").toLowerCase().includes(query) ||
        (s.tag||"").toLowerCase().includes(query) ||
        (s.group||"").toLowerCase().includes(query) ||
        (s.slipId||"").toLowerCase().includes(query) ||
        (s.players || []).some(p => `${p.name} ${p.ou} ${p.line}`.toLowerCase().includes(query))
      );
    }

    const sortBy = $("sortBy").value;
    out.sort((a,b) => {
      if(sortBy === "date_desc") return (b.date||"").localeCompare(a.date||"") || (b.createdAt||0)-(a.createdAt||0);
      if(sortBy === "date_asc")  return (a.date||"").localeCompare(b.date||"") || (a.createdAt||0)-(b.createdAt||0);
      if(sortBy === "stake_desc") return num(b.stake)-num(a.stake);
      if(sortBy === "stake_asc")  return num(a.stake)-num(b.stake);
      return 0;
    });

    return out;
  }

  function kpiCard(label, valueHtml){
    const d = document.createElement("div");
    d.className = "kpi";
    d.innerHTML = `<div class="k">${label}</div><div class="v">${valueHtml}</div>`;
    return d;
  }

  function renderAnalystProfiles(done){
    const profiles = analyzeAnalystProfiles(done);
    const analystIds = Object.keys(profiles).sort();
    const primarySelect = $("analystPrimary");
    const compareSelect = $("analystCompare");
    const grid = $("profileGrid");

    if(!primarySelect || !compareSelect || !grid) return;

    primarySelect.innerHTML = analystIds.map(id => `<option value="${escapeHtml(id)}">${escapeHtml(id)}</option>`).join("");
    compareSelect.innerHTML = `<option value="">None</option>` + analystIds.map(id => `<option value="${escapeHtml(id)}">${escapeHtml(id)}</option>`).join("");

    if(!analystIds.length){
      grid.innerHTML = `<div class="muteline">No finished slips yet. Profiles appear after closing out slips.</div>`;
      return;
    }

    if(!analystIds.includes(state.analystPrimary)){
      state.analystPrimary = analystIds[0];
    }
    if(state.analystCompare && !analystIds.includes(state.analystCompare)){
      state.analystCompare = "";
    }
    primarySelect.value = state.analystPrimary;
    compareSelect.value = state.analystCompare;

    const cards = [];
    const primaryProfile = profiles[state.analystPrimary];
    if(primaryProfile) cards.push(renderProfileCard(primaryProfile, "Primary"));
    if(state.analystCompare && profiles[state.analystCompare]){
      cards.push(renderProfileCard(profiles[state.analystCompare], "Comparison"));
    }
    grid.innerHTML = cards.join("");
  }

  function renderProfileCard(profile, label){
    const summary = profile.summary;
    const trends = profile.trends;
    const strengths = profile.strengths;
    const weaknesses = profile.weaknesses;
    const detail = profile.detail;
    const statusClass = summary.status === "HOT" ? "pos" : summary.status === "COLD" ? "neg" : "neu";
    return `
      <div class="profile-card">
        <div>
          <div class="profile-pill">${label}</div>
          <h3>${escapeHtml(profile.analystId)}</h3>
          <div class="profile-meta">${escapeHtml(profile.analystType)} • ${detail.wins}W-${detail.losses}L-${detail.pushes}P • ${detail.totalStaked ? fmtMoney(detail.totalStaked) : fmtMoney(0)} staked</div>
        </div>
        <div class="profile-stats">
          <div class="profile-stat"><div class="k">ROI</div><div class="v mono">${fmtPct(summary.ROI)}</div></div>
          <div class="profile-stat"><div class="k">Hit Rate</div><div class="v mono">${fmtPct(summary.hitRate)}</div></div>
          <div class="profile-stat"><div class="k">Edge</div><div class="v mono">${fmtPct(summary.edge)}</div></div>
          <div class="profile-stat"><div class="k">Profit / $100</div><div class="v mono">${fmtMoney(summary.profitPer100)}</div></div>
          <div class="profile-stat"><div class="k">Volatility</div><div class="v mono">${summary.volatility}</div></div>
          <div class="profile-stat"><div class="k">Max Drawdown</div><div class="v mono">${fmtPct(summary.maxDrawdown)}</div></div>
          <div class="profile-stat"><div class="k">Last 10 ROI</div><div class="v mono">${fmtPct(trends.last10ROI)}</div></div>
          <div class="profile-stat"><div class="k">Trend</div><div class="v ${statusClass}">${trends.direction} • ${summary.status}</div></div>
          <div class="profile-stat"><div class="k">Composite Score</div><div class="v mono">${detail.compositeScore.toFixed(1)}</div></div>
          <div class="profile-stat"><div class="k">Luck Factor</div><div class="v mono">${detail.luckFactor >= 0 ? "+" : ""}${detail.luckFactor.toFixed(2)}u</div></div>
        </div>
        <div class="profile-list">
          <div><strong>Strengths:</strong> ${escapeHtml(strengths.bestMarket)} market, ${escapeHtml(strengths.bestOddsRange)} odds, ${escapeHtml(strengths.bestSlipType)} slips</div>
          <div><strong>Weaknesses:</strong> ${escapeHtml(weaknesses.worstMarket)} market, ${weaknesses.overLegging ? "Over-legging risk" : "Leg structure ok"}, ${weaknesses.highVariance ? "High variance" : "Controlled variance"}</div>
          <div><strong>Consistency:</strong> Last 25 ROI ${fmtPct(trends.last25ROI)} • Avg drawdown ${fmtPct(detail.drawdownStats.avgDrawdownPct)} • Avg recovery ${detail.drawdownStats.avgRecovery.toFixed(1)} slips</div>
          <div><strong>Discipline:</strong> Longest losing streak ${detail.losingStreaks.longest} • Avg losing streak ${detail.losingStreaks.average.toFixed(1)}</div>
          <div><strong>Confidence:</strong> Calibration ${Math.round(detail.confidenceAccuracy * 100)}%</div>
        </div>
      </div>
    `;
  }

  function moneySpan(n){
    const v = num(n);
    const cls = v > 0 ? "pos" : (v < 0 ? "neg" : "neu");
    return `<span class="${cls}">${v >= 0 ? "+" : ""}${fmtMoney(v)}</span>`;
  }

  function render(){
    refreshDateDropdown();
    refreshGroupDropdown();
    refreshDatalists();
    refreshAnalystSelector();
    setBodyView();

    $("bankroll").value = String(state.startingBankroll || "");
    $("autosave").value = state.autosave;
    $("logView").value = state.logView || "auto";
    $("kpiView").value = state.kpiView || "overall";

    const shown = applyFilters(state.slips);

    // TABLE
    const tbody = $("rows");
    tbody.innerHTML = "";
    for(const s of shown){
      const p = payoutFor(s);
      const pl = plFor(s);

      const payoutCell = (p === null) ? `<span style="color:rgba(255,255,255,.45)">—</span>` : fmtMoney(p);
      const plCell = (pl === null) ? `<span style="color:rgba(255,255,255,.45)">—</span>`
        : `<span class="${pl>0?'pos':(pl<0?'neg':'neu')}">${pl>=0?'+':''}${fmtMoney(pl)}</span>`;

      const paidCell = (s.paidMult === "" || s.paidMult === null || s.paidMult === undefined)
        ? `<span style="color:rgba(255,255,255,.45)">—</span>`
        : `<span class="mono">${num(s.paidMult).toFixed(2)}x</span>`;

    const playersText = (s.players || [])
      .map(p => `${p.name} ${p.ou} ${p.line}`)
      .join(" • ");
    const tr = document.createElement("tr");
    tr.innerHTML = `
      <td class="mono">${escapeHtml(s.date||"")}</td>
      <td>${statusPill(s)}</td>
      <td>${escapeHtml(s.app||"")}</td>
      <td>${escapeHtml(s.sportsbook||"")}</td>
      <td>${escapeHtml(s.league||"")}</td>
      <td>${escapeHtml(s.oddsType||"")}</td>
      <td>${escapeHtml(s.creator||"")}</td>
      <td class="right mono">${fmtMoney(s.stake)}</td>
      <td class="right mono">${num(s.mult).toFixed(2)}x</td>
      <td class="right">${paidCell}</td>
      <td class="right mono">${payoutCell}</td>
      <td class="right">${plCell}</td>
      <td>${escapeHtml(s.tag||"")}</td>
      <td>${escapeHtml(s.group||"")}</td>
      <td class="mono">${escapeHtml(s.slipId||"")}</td>
      <td class="notes-trunc" title="${escapeHtml(playersText)}">${escapeHtml(playersText)}</td>
      <td class="right">
        <button class="kebab" title="Actions" data-kebab="${s.id}">⋯</button>
      </td>
    `;
      tbody.appendChild(tr);
    }

    // CARDS
    const cards = $("cards");
    cards.innerHTML = "";
    for(const s of shown){
      const p = payoutFor(s);
      const pl = plFor(s);
      const payoutText = (p === null) ? "—" : fmtMoney(p);
      const plText = (pl === null) ? "—" : `${pl>=0?"+":""}${fmtMoney(pl)}`;
      const plCls = (pl === null) ? "neu" : (pl>0 ? "pos" : pl<0 ? "neg" : "neu");

      const paidText = (s.paidMult === "" || s.paidMult === null || s.paidMult === undefined) ? "—" : `${num(s.paidMult).toFixed(2)}x`;
      const playersList = (s.players || [])
        .map(p => `${p.name} ${p.ou} ${p.line}`)
        .join("\n");

      const el = document.createElement("div");
      el.className = "slipCard";
      el.innerHTML = `
        <div class="top">
          <div>
            <div class="meta">
              <span class="mono">${escapeHtml(s.date||"")}</span>
              ${statusPill(s)}
              ${s.app ? `<span>• ${escapeHtml(s.app)}</span>` : ""}
              ${s.sportsbook ? `<span>• ${escapeHtml(s.sportsbook)}</span>` : ""}
              ${s.league ? `<span>• ${escapeHtml(s.league)}</span>` : ""}
              ${s.oddsType ? `<span>• ${escapeHtml(s.oddsType)}</span>` : ""}
              ${s.tag ? `<span>• ${escapeHtml(s.tag)}</span>` : ""}
              ${s.group ? `<span>• ${escapeHtml(s.group)}</span>` : ""}
              ${s.creator ? `<span>• ${escapeHtml(s.creator)}</span>` : ""}
            </div>
          </div>
          <button class="kebab" title="Actions" data-kebab="${s.id}">⋯</button>
        </div>

        <div class="grid2">
          <div class="kv"><div class="k">Stake</div><div class="v mono">${fmtMoney(s.stake)}</div></div>
          <div class="kv"><div class="k">Multiplier</div><div class="v mono">${num(s.mult).toFixed(2)}x</div></div>
          <div class="kv"><div class="k">Paid x</div><div class="v mono">${paidText}</div></div>
          <div class="kv"><div class="k">Payout</div><div class="v mono">${payoutText}</div></div>
          <div class="kv"><div class="k">Profit/Loss</div><div class="v mono ${plCls}">${plText}</div></div>
          <div class="kv"><div class="k">Slip ID</div><div class="v mono">${escapeHtml(s.slipId||"—")}</div></div>
          <div class="kv"><div class="k">Group</div><div class="v mono">${escapeHtml(s.group||"—")}</div></div>
        </div>

        ${playersList ? `<div class="notes">${escapeHtml(playersList)}</div>` : ""}
      `;
      cards.appendChild(el);
    }

    // KPIs
    const view = $("viewDate").value || todayISO();
    const dayDone = state.slips.filter(s => s.date === view && s.status === "DONE");
    const dayStaked = dayDone.reduce((a,s)=>a+num(s.stake),0);
    const dayPaid = dayDone.reduce((a,s)=>a + (payoutFor(s) ?? 0),0);
    const dayNet = dayPaid - dayStaked;
    const dayRoi = dayStaked > 0 ? dayNet/dayStaked : 0;

    const done = state.slips.filter(s => s.status === "DONE");
    const {staked: allStaked, paid: allPaid, net: allNet, roi: allRoi} = statsForDone(done);
    const doneCount = done.length;
    const wins = done.filter(s => s.result === "W").length;
    const winRate = doneCount > 0 ? wins / doneCount : 0;
    const avgStake = doneCount > 0 ? allStaked / doneCount : 0;
    const avgMult = doneCount > 0 ? done.reduce((a,s)=>a+num(s.mult),0) / doneCount : 0;

    const pendingCount = state.slips.filter(s=>s.status==="PENDING").length;
    const endBankroll = num(state.startingBankroll) + allNet;

    const kpis = $("kpis");
    kpis.innerHTML = "";
    if(state.kpiView === "creators"){
      const creatorGroups = [
        {label: "VIP Analysts", creators: ["JAY","ENVIXITY","OCHAN"]},
        {label: "Tryout Analysts", creators: ["FLUID","POPS"]},
        {label: "Own Slips", creators: ["CHUY","MIX"]}
      ];

      for(const group of creatorGroups){
        const groupDone = done.filter(s => group.creators.includes(String(s.creator || "").toUpperCase()));
        const stats = statsForDone(groupDone);
        kpis.appendChild(kpiCard(`${group.label} Net`, moneySpan(stats.net)));
        kpis.appendChild(kpiCard(`${group.label} ROI`, `<span class="mono">${fmtPct(stats.roi)}</span>`));
      }
    }else{
      kpis.appendChild(kpiCard(`Selected Day Net (${view})`, moneySpan(dayNet)));
      kpis.appendChild(kpiCard(`Selected Day ROI`, `<span class="mono">${fmtPct(dayRoi)}</span>`));
      kpis.appendChild(kpiCard(`All-Time Net`, moneySpan(allNet)));
      kpis.appendChild(kpiCard(`All-Time ROI`, `<span class="mono">${fmtPct(allRoi)}</span>`));
      kpis.appendChild(kpiCard(`Win Rate`, `<span class="mono">${fmtPct(winRate)}</span>`));
      kpis.appendChild(kpiCard(`Avg Stake`, `<span class="mono">${fmtMoney(avgStake)}</span>`));
      kpis.appendChild(kpiCard(`Avg Multiplier`, `<span class="mono">${avgMult.toFixed(2)}x</span>`));
      kpis.appendChild(kpiCard(`Pending Slips`, `<span class="mono">${pendingCount}</span>`));
    }

    $("bankrollLine").innerHTML =
      `Starting bankroll: <b class="mono">${fmtMoney(state.startingBankroll)}</b> → Current (finished slips): <b class="mono">${fmtMoney(endBankroll)}</b>`;

    renderBankrollChart(done, endBankroll);
    renderAnalystProfiles(done);
  }

  function renderBankrollChart(done, endBankroll){
    const canvas = $("bankrollChart");
    if(!canvas) return;
    const ctx = canvas.getContext("2d");
    const width = canvas.width;
    const height = canvas.height;
    ctx.clearRect(0,0,width,height);

    if(done.length === 0){
      ctx.fillStyle = "rgba(255,255,255,0.55)";
      ctx.font = "12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif";
      ctx.fillText("No finished slips yet.", 12, 20);
      return;
    }

    const sorted = done.slice().sort((a,b) => {
      const dateSort = (a.date||"").localeCompare(b.date||"");
      if(dateSort !== 0) return dateSort;
      return (a.createdAt||0) - (b.createdAt||0);
    });

    const points = [];
    let bank = num(state.startingBankroll);
    points.push(bank);
    for(const s of sorted){
      bank += plFor(s) ?? 0;
      points.push(bank);
    }

    const minVal = Math.min(...points);
    const maxVal = Math.max(...points);
    const range = Math.max(1, maxVal - minVal);
    const padding = 16;

    const xStep = (width - padding * 2) / Math.max(1, points.length - 1);
    const yFor = (val) => height - padding - ((val - minVal) / range) * (height - padding * 2);

    ctx.strokeStyle = "rgba(255,255,255,0.2)";
    ctx.beginPath();
    ctx.moveTo(padding, padding);
    ctx.lineTo(padding, height - padding);
    ctx.lineTo(width - padding, height - padding);
    ctx.stroke();

    ctx.strokeStyle = "rgba(110,168,255,0.85)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    points.forEach((val, i) => {
      const x = padding + i * xStep;
      const y = yFor(val);
      if(i === 0) ctx.moveTo(x,y);
      else ctx.lineTo(x,y);
    });
    ctx.stroke();

    ctx.fillStyle = "rgba(255,255,255,0.65)";
    ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, \"Liberation Mono\",\"Courier New\", monospace";
    ctx.fillText(`End: ${fmtMoney(endBankroll)}`, padding, height - 6);
  }

  function readSlipFromForm(forcePending=false){
    const date = $("date").value || todayISO();
    const status = forcePending ? "PENDING" : $("status").value;
    const result = $("result").value;
    const app = $("app").value.trim();
    const sportsbook = $("sportsbook").value.trim();
    const league = $("league").value.trim();
    const oddsType = $("oddsType").value;
    const stake = num($("stake").value);
    const mult = num($("mult").value);
    const oddsDecimalInput = num($("oddsDecimal")?.value);
    const paidRaw = $("paid").value;
    const paidMult = (paidRaw === "" ? "" : num(paidRaw));
    const tag = $("tag").value.trim();
    let tags = parseTags($("tags")?.value);
    if(!tags.length && tag) tags = parseTags(tag);
    const group = $("group").value.trim();
    const creator = $("creator") ? $("creator").value : "CHUY";
    const analystId = $("analystId").value.trim();
    const analystType = $("analystType").value;
    const slipType = $("slipType").value;
    const legsCount = num($("legsCount").value);
    const marketType = $("marketType")?.value.trim() || "Player props";
    const confidenceRaw = $("confidence")?.value || "";
    const confidence = confidenceRaw ? num(confidenceRaw) : null;
    const slipId = $("slipId").value.trim();
    const players = readPlayersFromForm();
    if(players === null) return null;

    if(stake <= 0) return alert("Stake must be > 0"), null;
    if(mult <= 0) return alert("Listed multiplier must be > 0"), null;
    const oddsDecimal = oddsDecimalInput > 0 ? oddsDecimalInput : mult;
    if(oddsDecimal <= 0) return alert("Odds (decimal) must be > 0"), null;
    if(players.length === 0) return alert("Add at least one player/prop."), null;

    return {
      id: genId(),
      createdAt: Date.now(),
      date, status,
      result: status==="DONE" ? result : "",
      app, sportsbook, league, oddsType,
      creator,
      analystId: analystId || creator,
      analystType: analystType || deriveAnalystType(analystId || creator),
      slipType: slipType || (players.length > 1 ? "Parlay" : "Straight"),
      legsCount: legsCount > 0 ? legsCount : Math.max(1, players.length),
      marketType,
      confidence: (confidence === null ? null : confidence),
      stake, mult, oddsDecimal, paidMult, tag, tags, group, slipId, players
    };
  }

  function clearForm(){
    const setValue = (id, value) => {
      const el = $(id);
      if(el) el.value = value;
    };
    setValue("app", "");
    setValue("sportsbook", "");
    setValue("league", "");
    setValue("oddsType", "");
    setValue("stake", "");
    setValue("mult", "");
    setValue("oddsDecimal", "");
    setValue("paid", "");
    setValue("tag", "");
    setValue("tags", "");
    setValue("group", "");
    setValue("slipId", "");
    setValue("creator", "CHUY");
    setValue("analystId", "Chuy");
    setValue("analystType", "Own");
    setValue("slipType", "");
    setValue("legsCount", "");
    setValue("marketType", "");
    setValue("confidence", "");
    renderPlayers([]);
  }

  // Import/Export
  function downloadFile(filename, content, mime){
    const blob = new Blob([content], {type:mime});
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url; a.download = filename; a.click();
    URL.revokeObjectURL(url);
  }

  function exportTxt(){
    const payload = {
      version: 2,
      exportedAt: new Date().toISOString(),
      startingBankroll: state.startingBankroll,
      autosave: state.autosave,
      logView: state.logView,
      kpiView: state.kpiView,
      analystPrimary: state.analystPrimary,
      analystCompare: state.analystCompare,
      slips: state.slips
    };
    downloadFile(`slips-${todayISO()}.txt`, JSON.stringify(payload,null,2), "text/plain");
  }

  function exportCsv(){
    const cols = ["date","status","result","app","sportsbook","league","oddsType","creator","analystId","analystType","slipType","legsCount","marketType","confidence","tags","stake","mult","oddsDecimal","paidMult","payout","profitLoss","tag","group","slipId","players"];
    const lines = [cols.join(",")];
    for(const s of state.slips){
      const p = payoutFor(s);
      const pl = plFor(s);
      const playersCsv = (s.players || [])
        .map(player => `${player.name} ${player.ou} ${player.line}`)
        .join(" | ");
      const row = [
        s.date, s.status, s.result, s.app, s.sportsbook, s.league, s.oddsType, s.creator,
        s.analystId, s.analystType, s.slipType, s.legsCount, s.marketType, s.confidence,
        Array.isArray(s.tags) ? s.tags.join("|") : "",
        s.stake, s.mult, s.oddsDecimal, (s.paidMult===""? "" : s.paidMult),
        (p===null? "" : p),
        (pl===null? "" : pl),
        s.tag, s.group, s.slipId,
        playersCsv
      ].map(v => {
        const str = String(v ?? "");
        return /[",\n]/.test(str) ? `"${str.replaceAll('"','""')}"` : str;
      });
      lines.push(row.join(","));
    }
    downloadFile(`slips-${todayISO()}.csv`, lines.join("\n"), "text/csv");
  }

  async function importTxt(file){
    try{
      const text = await file.text();
      const parsed = JSON.parse(text);

      if(parsed.startingBankroll !== undefined) state.startingBankroll = num(parsed.startingBankroll);
      state.autosave = parsed.autosave === "off" ? "off" : "on";
      state.logView = (parsed.logView === "table" || parsed.logView === "cards") ? parsed.logView : "auto";
      state.kpiView = parsed.kpiView === "creators" ? "creators" : "overall";
      state.analystPrimary = parsed.analystPrimary || "";
      state.analystCompare = parsed.analystCompare || "";

      if(Array.isArray(parsed.slips)) state.slips = parsed.slips;

      // normalize
      state.slips = state.slips.map(s => ({
        id: s.id || genId(),
        createdAt: s.createdAt || Date.now(),
        date: s.date || "",
        status: s.status === "DONE" ? "DONE" : "PENDING",
        result: s.result || "",
        app: s.app || "",
        sportsbook: s.sportsbook || "",
        league: s.league || "",
        oddsType: s.oddsType || "",
        creator: s.creator || "CHUY",
        analystId: s.analystId || s.creator || "CHUY",
        analystType: s.analystType || deriveAnalystType(s.analystId || s.creator || "CHUY"),
        slipType: s.slipType || ((Array.isArray(s.players) ? s.players.length : 0) > 1 ? "Parlay" : "Straight"),
        legsCount: num(s.legsCount) || ((Array.isArray(s.players) ? s.players.length : 0) || 1),
        marketType: s.marketType || "",
        confidence: (Number.isFinite(Number(s.confidence)) ? num(s.confidence) : null),
        stake: num(s.stake),
        mult: num(s.mult),
        oddsDecimal: num(s.oddsDecimal) || num(s.mult),
        paidMult: (s.paidMult === undefined ? "" : s.paidMult),
        tag: s.tag || "",
        tags: Array.isArray(s.tags) ? s.tags : parseTags(s.tags || s.tag || ""),
        group: s.group || "",
        slipId: s.slipId || "",
        players: Array.isArray(s.players) ? s.players : ((s.notes && !s.players) ? [{name: s.notes, line: "", ou: ""}] : [])
      }));

      save();
      render();
    }catch{
      alert("Import failed. Use a file exported from this tracker.");
    }
  }

  // ---- Kebab menu logic ----
  const menu = $("menu");
  const menuTitle = $("menuTitle");
  const menuPaid = $("menuPaid");
  let activeSlipId = null;

  function closeMenu(){
    menu.style.display = "none";
    activeSlipId = null;
  }

  function openMenuForSlip(slipId, anchorRect){
    const s = state.slips.find(x => x.id === slipId);
    if(!s) return;

    activeSlipId = slipId;
    menuTitle.textContent = `Slip • ${s.date} • ${fmtMoney(s.stake)} @ ${num(s.mult).toFixed(2)}x`;
    menuPaid.value = (s.paidMult === "" || s.paidMult === null || s.paidMult === undefined) ? "" : String(s.paidMult);

    // Mobile: bottom sheet handled by CSS, just show
    if(window.matchMedia("(max-width: 600px)").matches){
      menu.style.display = "block";
      return;
    }

    // Desktop positioning near kebab
    const margin = 10;
    const width = 330;
    const heightGuess = 300;

    let left = anchorRect.right + margin;
    if(left + width > window.innerWidth - 10) left = anchorRect.left - width - margin;
    left = Math.max(10, Math.min(left, window.innerWidth - width - 10));

    let top = anchorRect.top;
    if(top + heightGuess > window.innerHeight - 10) top = window.innerHeight - heightGuess - 10;
    top = Math.max(10, top);

    menu.style.left = left + "px";
    menu.style.top = top + "px";
    menu.style.display = "block";
  }

  function setSlipStatusResult(id, status, result){
    const s = state.slips.find(x => x.id === id);
    if(!s) return;
    s.status = status;
    s.result = status === "DONE" ? result : "";
    save(); render();
  }

  function setPaidMult(id, val){
    const s = state.slips.find(x => x.id === id);
    if(!s) return;
    s.paidMult = (val === "" ? "" : num(val));
    save(); render();
  }

  function deleteSlip(id){
    state.slips = state.slips.filter(s => s.id !== id);
    save(); render();
  }

  // Events
  $("addBtn").addEventListener("click", () => {
    const slip = readSlipFromForm(false);
    if(!slip) return;
    if(slip.status === "DONE" && !slip.result) return alert("Pick a result for finished slips.");
    state.slips.push(slip);
    save(); clearForm(); render();
  });

  $("addPendingBtn").addEventListener("click", () => {
    const slip = readSlipFromForm(true);
    if(!slip) return;
    slip.status = "PENDING"; slip.result = "";
    state.slips.push(slip);
    save(); clearForm(); render();
  });

  $("clearBtn").addEventListener("click", () => {
    if(!confirm("Clear ALL slips?")) return;
    state.slips = [];
    save(); render();
  });

  $("addPlayerBtn").addEventListener("click", () => {
    const current = readPlayersDraft();
    current.push({name:"", line:"", ou:""});
    renderPlayers(current);
  });

  playersContainer().addEventListener("click", (e) => {
    if(!e.target.closest(".remove-player")) return;
    const rows = Array.from(playersContainer().querySelectorAll("[data-player-row]"));
    const row = e.target.closest("[data-player-row]");
    const index = rows.indexOf(row);
    const current = readPlayersDraft();
    current.splice(index, 1);
    renderPlayers(current);
  });

  $("exportBtn").addEventListener("click", exportTxt);
  $("exportCsvBtn").addEventListener("click", exportCsv);

  $("importFile").addEventListener("change", async (e) => {
    const file = e.target.files && e.target.files[0];
    if(file) await importTxt(file);
    e.target.value = "";
  });

  $("bankroll").addEventListener("input", (e) => {
    state.startingBankroll = num(e.target.value);
    save(); render();
  });

  $("autosave").addEventListener("change", (e) => {
    state.autosave = e.target.value;
    if(state.autosave === "on") save();
  });

  $("logView").addEventListener("change", (e) => {
    state.logView = e.target.value;
    save(); render();
  });

  $("kpiView").addEventListener("change", (e) => {
    state.kpiView = e.target.value === "creators" ? "creators" : "overall";
    save(); render();
  });

  $("analystPrimary").addEventListener("change", (e) => {
    state.analystPrimary = e.target.value;
    save(); render();
  });

  $("analystCompare").addEventListener("change", (e) => {
    state.analystCompare = e.target.value;
    save(); render();
  });

  $("viewDate").addEventListener("change", render);
  $("filterStatus").addEventListener("change", render);
  $("filterDate").addEventListener("change", render);
  $("filterGroup").addEventListener("change", render);
  $("sortBy").addEventListener("change", render);
  $("search").addEventListener("input", render);

  $("status").addEventListener("change", () => {
    const done = $("status").value === "DONE";
    $("result").disabled = !done;
  });

  $("creator").addEventListener("change", () => {
    const analystId = $("analystId");
    if(analystId && !analystId.value.trim()){
      analystId.value = $("creator").value;
      syncAnalystType(analystId.value);
    }
  });

  $("analystId").addEventListener("change", (e) => {
    syncAnalystType(e.target.value);
  });

  // open kebab menu (works for table + cards)
  document.addEventListener("click", (e) => {
    const kb = e.target.closest("[data-kebab]");
    if(kb){
      const id = kb.getAttribute("data-kebab");
      const rect = kb.getBoundingClientRect();
      if(activeSlipId === id && menu.style.display === "block") closeMenu();
      else openMenuForSlip(id, rect);
      return;
    }
    if(menu.style.display === "block" && !e.target.closest("#menu")) closeMenu();
  });

  document.addEventListener("keydown", (e) => {
    if(e.key === "Escape") closeMenu();
  });

  $("menuClose").addEventListener("click", closeMenu);

  $("actPending").addEventListener("click", () => { if(activeSlipId){ setSlipStatusResult(activeSlipId,"PENDING",""); closeMenu(); }});
  $("actWin").addEventListener("click", () => { if(activeSlipId){ setSlipStatusResult(activeSlipId,"DONE","W"); closeMenu(); }});
  $("actLoss").addEventListener("click", () => { if(activeSlipId){ setSlipStatusResult(activeSlipId,"DONE","L"); closeMenu(); }});
  $("actPush").addEventListener("click", () => { if(activeSlipId){ setSlipStatusResult(activeSlipId,"DONE","P"); closeMenu(); }});
  $("actSavePaid").addEventListener("click", () => { if(activeSlipId){ setPaidMult(activeSlipId, menuPaid.value); closeMenu(); }});
  $("actDelete").addEventListener("click", () => {
    if(!activeSlipId) return;
    if(!confirm("Delete this slip?")) return;
    deleteSlip(activeSlipId);
    closeMenu();
  });

  // Init
  load();
  $("date").value = todayISO();
  $("viewDate").value = todayISO();
  $("result").disabled = ($("status").value !== "DONE");
  $("creator").value = "CHUY";
  $("analystId").value = DEFAULT_ANALYST_ID;
  syncAnalystType(DEFAULT_ANALYST_ID);
  renderPlayers([]);
  render();

  // re-render on resize (so Auto view switches smoothly)
  window.addEventListener("resize", () => {
    if(state.logView === "auto") setBodyView();
  });
})();
</script>
</body>
</html>
